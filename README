# Pony Programme README

## Optimal Work Unit Size

The size of the work unit that resulted in the best performance for our implementation is [X] sub-problems per worker request.

We determined this optimal size through the following process:
1. [Explain your methodology for testing different work unit sizes]
2. [Describe how you measured and compared performance]
3. [Mention any trade-offs considered]

## Results for lukas 1000000 4

The result of running our program with the inputs `1000000 4` is:

[Insert the output here]

## Performance Metrics

We ran the program using the command:
For macOS - /usr/bin/time ./DOSP 1000000 4
For Windows Powershell - .\measure_time.ps1 -ProgramPath ".\DOSP.exe" -Arguments "1000000 4"

The results were:

- Real time: [X] seconds
- User time: [Y] seconds
- Sys time: [Z] seconds

The ratio of CPU time (User + Sys) to Real time is [calculate and insert ratio]. This ratio indicates that our implementation effectively utilized [calculate and insert number] cores for parallel computation.

## Largest Problem Solved

The largest problem we managed to solve with our implementation was:

- Problem type: [e.g., Lukas sequence calculation]
- Input size: [Insert the largest input size successfully processed]
- Number of workers: [Insert the number of workers used]

This demonstrates the scalability and efficiency of our pony-based parallel implementation.

## Additional Notes

[Include any other relevant information, such as:
- Challenges faced and how they were overcome
- Potential improvements or future work
- Any special instructions for running the program]

